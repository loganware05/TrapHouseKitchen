<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TrapHouse Kitchen â€” Review System Evaluation</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Syne:wght@400;600;700;800&family=IBM+Plex+Mono:wght@400;500&family=Lora:ital,wght@0,400;0,600;1,400&display=swap');

  :root {
    --bg: #0e0c0a;
    --surface: #181512;
    --surface2: #221e18;
    --border: #2e2820;
    --accent: #e8622a;
    --accent2: #f0a04b;
    --green: #4caf78;
    --red: #d94f4f;
    --yellow: #e8b94a;
    --blue: #4a90d9;
    --text: #e8e2d8;
    --muted: #8a7e6e;
    --code-bg: #12100e;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Lora', Georgia, serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.75;
    font-size: 16px;
  }

  /* â”€â”€â”€ HERO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .hero {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 64px 48px 48px;
    position: relative;
    overflow: hidden;
  }

  .hero::before {
    content: '';
    position: absolute;
    top: -80px; right: -80px;
    width: 360px; height: 360px;
    background: radial-gradient(circle, rgba(232,98,42,0.18) 0%, transparent 70%);
    pointer-events: none;
  }

  .hero-label {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--accent);
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .hero-label::before {
    content: '';
    display: block;
    width: 24px; height: 1px;
    background: var(--accent);
  }

  h1 {
    font-family: 'Syne', sans-serif;
    font-size: clamp(28px, 5vw, 52px);
    font-weight: 800;
    line-height: 1.1;
    color: #fff;
    margin-bottom: 16px;
  }

  h1 span { color: var(--accent); }

  .hero-sub {
    color: var(--muted);
    font-size: 16px;
    max-width: 600px;
    font-style: italic;
  }

  .meta-row {
    display: flex;
    gap: 32px;
    margin-top: 36px;
    flex-wrap: wrap;
  }

  .meta-item {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .meta-item .label {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 10px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--muted);
  }

  .meta-item .value {
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 15px;
    color: var(--text);
  }

  /* â”€â”€â”€ LAYOUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .container {
    max-width: 900px;
    margin: 0 auto;
    padding: 0 48px 80px;
  }

  /* â”€â”€â”€ SECTION HEADERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .section {
    margin-top: 64px;
  }

  .section-header {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 28px;
  }

  .section-num {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    color: var(--accent);
    background: rgba(232,98,42,0.12);
    border: 1px solid rgba(232,98,42,0.3);
    padding: 2px 8px;
    border-radius: 3px;
  }

  h2 {
    font-family: 'Syne', sans-serif;
    font-size: 22px;
    font-weight: 700;
    color: #fff;
    letter-spacing: -0.02em;
  }

  /* â”€â”€â”€ CALLOUT BOXES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .callout {
    border-radius: 8px;
    padding: 20px 24px;
    margin: 20px 0;
    border-left: 3px solid;
  }

  .callout.critical {
    background: rgba(217,79,79,0.1);
    border-color: var(--red);
  }

  .callout.warning {
    background: rgba(232,185,74,0.1);
    border-color: var(--yellow);
  }

  .callout.info {
    background: rgba(74,144,217,0.1);
    border-color: var(--blue);
  }

  .callout.success {
    background: rgba(76,175,120,0.1);
    border-color: var(--green);
  }

  .callout-title {
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 13px;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .callout.critical .callout-title { color: var(--red); }
  .callout.warning .callout-title { color: var(--yellow); }
  .callout.info .callout-title { color: var(--blue); }
  .callout.success .callout-title { color: var(--green); }

  .callout p, .callout li { font-size: 14.5px; color: var(--text); }
  .callout ul { padding-left: 18px; }
  .callout li { margin-top: 5px; }

  /* â”€â”€â”€ CODE BLOCKS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .code-block {
    background: var(--code-bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    margin: 20px 0;
    font-size: 13px;
  }

  .code-block-header {
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    padding: 10px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    color: var(--muted);
  }

  .code-block-header .filename { color: var(--accent2); }
  .code-block-header .lang { color: var(--muted); }

  pre {
    padding: 20px;
    overflow-x: auto;
    font-family: 'IBM Plex Mono', monospace;
    line-height: 1.65;
    color: #c8c0b0;
  }

  .token-keyword { color: #cc99cd; }
  .token-string { color: #7ec8a0; }
  .token-comment { color: #5a5448; font-style: italic; }
  .token-function { color: #86b5d4; }
  .token-number { color: #e8b94a; }
  .token-error { color: var(--red); text-decoration: underline wavy; }
  .token-fix { color: var(--green); }
  .token-highlight { background: rgba(232,98,42,0.2); border-radius: 2px; padding: 0 2px; }

  /* â”€â”€â”€ FLOW DIAGRAM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .flow {
    display: grid;
    gap: 0;
    margin: 24px 0;
  }

  .flow-step {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    position: relative;
  }

  .flow-step:not(:last-child)::after {
    content: '';
    position: absolute;
    left: 17px;
    top: 36px;
    width: 1px;
    height: calc(100% - 4px);
    background: var(--border);
  }

  .flow-dot {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 12px;
    font-weight: 500;
    flex-shrink: 0;
    position: relative;
    z-index: 1;
  }

  .flow-dot.ok { background: rgba(76,175,120,0.15); border: 1.5px solid var(--green); color: var(--green); }
  .flow-dot.fail { background: rgba(217,79,79,0.15); border: 1.5px solid var(--red); color: var(--red); }
  .flow-dot.warn { background: rgba(232,185,74,0.15); border: 1.5px solid var(--yellow); color: var(--yellow); }

  .flow-content {
    padding: 8px 0 24px;
    flex: 1;
  }

  .flow-content strong {
    font-family: 'Syne', sans-serif;
    font-weight: 600;
    font-size: 15px;
    color: #fff;
    display: block;
    margin-bottom: 4px;
  }

  .flow-content p {
    font-size: 14px;
    color: var(--muted);
  }

  /* â”€â”€â”€ IMPROVEMENT CARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .improvements {
    display: grid;
    gap: 20px;
    margin-top: 24px;
  }

  .improvement-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 24px;
    transition: border-color 0.2s;
  }

  .improvement-card:hover { border-color: var(--accent); }

  .improvement-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 14px;
    gap: 12px;
  }

  .improvement-card h3 {
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 16px;
    color: #fff;
  }

  .priority-badge {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 10px;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    padding: 3px 9px;
    border-radius: 20px;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .priority-badge.high { background: rgba(217,79,79,0.15); border: 1px solid rgba(217,79,79,0.4); color: var(--red); }
  .priority-badge.medium { background: rgba(232,185,74,0.12); border: 1px solid rgba(232,185,74,0.4); color: var(--yellow); }
  .priority-badge.low { background: rgba(76,175,120,0.1); border: 1px solid rgba(76,175,120,0.3); color: var(--green); }

  .improvement-card p { font-size: 14.5px; color: var(--muted); margin-bottom: 14px; }

  /* â”€â”€â”€ DIVIDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .divider {
    border: none;
    border-top: 1px solid var(--border);
    margin: 48px 0;
  }

  /* â”€â”€â”€ SUMMARY TABLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .summary-table {
    width: 100%;
    border-collapse: collapse;
    margin: 20px 0;
    font-size: 14px;
  }

  .summary-table th {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 10px;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--muted);
    text-align: left;
    padding: 10px 16px;
    border-bottom: 1px solid var(--border);
    background: var(--surface);
  }

  .summary-table td {
    padding: 12px 16px;
    border-bottom: 1px solid var(--border);
    vertical-align: top;
    color: var(--text);
  }

  .summary-table tr:hover td { background: var(--surface); }

  .status-dot {
    display: inline-block;
    width: 8px; height: 8px;
    border-radius: 50%;
    margin-right: 8px;
  }

  .status-dot.red { background: var(--red); box-shadow: 0 0 6px rgba(217,79,79,0.6); }
  .status-dot.yellow { background: var(--yellow); box-shadow: 0 0 6px rgba(232,185,74,0.5); }
  .status-dot.green { background: var(--green); box-shadow: 0 0 6px rgba(76,175,120,0.5); }

  /* â”€â”€â”€ INLINE CODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  code {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 12.5px;
    background: var(--surface2);
    border: 1px solid var(--border);
    padding: 1px 6px;
    border-radius: 4px;
    color: var(--accent2);
  }

  /* â”€â”€â”€ PROSE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  p { margin-bottom: 14px; }

  strong { font-weight: 600; color: var(--text); }

  ul { padding-left: 20px; }
  ul li { margin-bottom: 6px; font-size: 14.5px; color: var(--text); }

  /* â”€â”€â”€ FOOTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .footer {
    background: var(--surface);
    border-top: 1px solid var(--border);
    padding: 24px 48px;
    text-align: center;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    color: var(--muted);
    letter-spacing: 0.05em;
  }
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• HERO â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="hero">
  <div class="hero-label">TrapHouse Kitchen â€” Code Evaluation</div>
  <h1>Review System<br><span>Bug Analysis & Improvements</span></h1>
  <p class="hero-sub">A full trace of the post-checkout review flow, the root cause of the breakage, a confirmed fix, and recommended improvements.</p>
  <div class="meta-row">
    <div class="meta-item"><span class="label">Evaluated</span><span class="value">February 12, 2026</span></div>
    <div class="meta-item"><span class="label">Project</span><span class="value">TrapHouse Kitchen v2</span></div>
    <div class="meta-item"><span class="label">Bug Severity</span><span class="value" style="color:var(--red)">Critical</span></div>
    <div class="meta-item"><span class="label">Tests Run</span><span class="value">8 / 8 Pass (headless only)</span></div>
  </div>
</div>

<div class="container">

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 1: SYSTEM TRACE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="section">
    <div class="section-header">
      <span class="section-num">01</span>
      <h2>How the Review Flow Is Supposed to Work</h2>
    </div>
    <p>Before diagnosing the break, here is the intended end-to-end path a customer takes after ordering a dish â€” from payment to submitting a review.</p>

    <div class="flow">
      <div class="flow-step">
        <div class="flow-dot ok">1</div>
        <div class="flow-content">
          <strong>Customer places order &amp; pays via Stripe</strong>
          <p>Stripe processes the payment. On success, a webhook fires <code>payment_intent.succeeded</code> to the backend.</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-dot ok">2</div>
        <div class="flow-content">
          <strong>Webhook updates order to <code>paymentStatus: PAID</code></strong>
          <p>The <code>webhook.routes.ts</code> handler sets the order's <code>paymentStatus</code> to <code>PAID</code> and <code>status</code> to <code>PENDING</code>.</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-dot ok">3</div>
        <div class="flow-content">
          <strong>Chef views order, prepares food, marks it <code>COMPLETED</code></strong>
          <p>Chef uses the dashboard to progress the order status to <code>COMPLETED</code>.</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-dot fail">4</div>
        <div class="flow-content">
          <strong>Customer navigates to Orders page â€” no "Write Review" button appears</strong>
          <p>The <code>OrdersPage</code> checks <code>/reviews/eligible-orders</code>. This endpoint queries for orders where <code>completedAt â‰¥ 30 days ago</code>. Since <code>completedAt</code> was never set on the order, zero orders are returned â€” making <code>canReviewOrder()</code> always <code>false</code>.</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-dot fail">5</div>
        <div class="flow-content">
          <strong>Customer navigates directly to <code>/reviews/new</code> â€” form shows "No orders available"</strong>
          <p>The <code>ReviewFormPage</code> fetches the same <code>eligible-orders</code> endpoint. Because <code>completedAt</code> is <code>null</code>, the query excludes every completed order and the form renders an empty state.</p>
        </div>
      </div>
    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 2: ROOT CAUSE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="section">
    <div class="section-header">
      <span class="section-num">02</span>
      <h2>Root Cause: <code>completedAt</code> Is Never Written</h2>
    </div>

    <div class="callout critical">
      <div class="callout-title">ğŸ”´ Critical Bug</div>
      <p>The <code>getEligibleOrders</code> controller queries for <code>completedAt: { gte: thirtyDaysAgo }</code>, but <strong>no part of the codebase ever writes a value to <code>completedAt</code></strong>. The field exists in the Prisma schema as <code>DateTime?</code> (nullable), so every order will have <code>completedAt = null</code> â€” which Prisma excludes from the <code>gte</code> filter automatically. The result is that the eligible-orders list is always empty, regardless of order or payment status.</p>
    </div>

    <p>There are two places the bug lives simultaneously:</p>

    <p><strong>Bug Location 1 â€” Webhook handler</strong> (<code>backend/src/routes/webhook.routes.ts</code>). When Stripe confirms payment, the order is updated but <code>completedAt</code> is never touched:</p>

    <div class="code-block">
      <div class="code-block-header">
        <span class="filename">backend/src/routes/webhook.routes.ts</span>
        <span class="lang">TypeScript â€” current (broken)</span>
      </div>
      <pre><span class="token-keyword">const</span> updatedOrder = <span class="token-keyword">await</span> prisma.order.<span class="token-function">update</span>({
  where: { id: payment.orderId },
  data: {
    status: <span class="token-string">'PENDING'</span>,      <span class="token-comment">// chef still needs to prepare it</span>
    paymentStatus: <span class="token-string">'PAID'</span>,
    <span class="token-comment">// âš ï¸  completedAt is never set here</span>
  },
});</pre>
    </div>

    <p><strong>Bug Location 2 â€” Chef order status update</strong> (<code>backend/src/routes/order.routes.ts</code> / <code>order.controller.ts</code>). When the chef marks an order as <code>COMPLETED</code>, <code>completedAt</code> is never written either. This is the moment that <em>should</em> stamp the timestamp:</p>

    <div class="code-block">
      <div class="code-block-header">
        <span class="filename">backend/src/controllers/order.controller.ts</span>
        <span class="lang">TypeScript â€” current (broken)</span>
      </div>
      <pre><span class="token-keyword">const</span> order = <span class="token-keyword">await</span> prisma.order.<span class="token-function">update</span>({
  where: { id },
  data: { status },   <span class="token-comment">// âš ï¸  completedAt never stamped when status â†’ 'COMPLETED'</span>
});</pre>
    </div>

    <div class="callout success">
      <div class="callout-title">âœ… The Fix â€” Two Lines</div>
      <p>Set <code>completedAt</code> conditionally whenever the status becomes <code>COMPLETED</code>. Apply this fix in <strong>every place</strong> an order's status is updated:</p>
    </div>

    <div class="code-block">
      <div class="code-block-header">
        <span class="filename">backend/src/controllers/order.controller.ts</span>
        <span class="lang">TypeScript â€” fixed</span>
      </div>
      <pre><span class="token-keyword">const</span> order = <span class="token-keyword">await</span> prisma.order.<span class="token-function">update</span>({
  where: { id },
  data: {
    status,
    <span class="token-fix">// Stamp completedAt the moment the chef marks the order done</span>
    <span class="token-fix">...(status === 'COMPLETED' && { completedAt: new Date() }),</span>
  },
});</pre>
    </div>

    <div class="code-block">
      <div class="code-block-header">
        <span class="filename">backend/src/routes/webhook.routes.ts</span>
        <span class="lang">TypeScript â€” context note</span>
      </div>
      <pre><span class="token-comment">// The webhook fires when payment succeeds, not when the order is completed.
// completedAt should NOT be set here â€” it belongs in the chef's status update.
// No change needed in the webhook itself, only in the status-update route.</span></pre>
    </div>

    <div class="callout warning">
      <div class="callout-title">âš ï¸ Additional Check â€” Existing Orders in Production</div>
      <p>Any orders already marked <code>COMPLETED</code> before this fix is deployed will still have <code>completedAt = null</code>. Run a one-time back-fill migration to stamp them:</p>
    </div>

    <div class="code-block">
      <div class="code-block-header">
        <span class="filename">One-time SQL back-fill</span>
        <span class="lang">SQL</span>
      </div>
      <pre><span class="token-comment">-- Sets completedAt to updatedAt for all already-completed orders</span>
<span class="token-keyword">UPDATE</span> <span class="token-string">"Order"</span>
<span class="token-keyword">SET</span>    <span class="token-string">"completedAt"</span> = <span class="token-string">"updatedAt"</span>
<span class="token-keyword">WHERE</span>  status = <span class="token-string">'COMPLETED'</span>
  <span class="token-keyword">AND</span>  <span class="token-string">"completedAt"</span> <span class="token-keyword">IS NULL</span>;</pre>
    </div>
  </div>

  <hr class="divider">

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 3: EVALUATION TABLE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="section">
    <div class="section-header">
      <span class="section-num">03</span>
      <h2>Full System Evaluation</h2>
    </div>
    <p>With the root cause identified, here is a broader snapshot of the review subsystem's current health across all layers.</p>

    <table class="summary-table">
      <thead>
        <tr>
          <th>Layer</th>
          <th>Component</th>
          <th>Status</th>
          <th>Notes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Database</td>
          <td><code>completedAt</code> field</td>
          <td><span class="status-dot red"></span>Broken</td>
          <td>Field exists but is never populated â€” root cause</td>
        </tr>
        <tr>
          <td>Backend</td>
          <td>Order status update route</td>
          <td><span class="status-dot red"></span>Broken</td>
          <td>No <code>completedAt</code> stamp when status â†’ COMPLETED</td>
        </tr>
        <tr>
          <td>Backend</td>
          <td><code>getEligibleOrders</code> controller</td>
          <td><span class="status-dot yellow"></span>Correct logic, broken input</td>
          <td>Filter logic is right; fails because <code>completedAt</code> is always null</td>
        </tr>
        <tr>
          <td>Backend</td>
          <td><code>createReview</code> controller</td>
          <td><span class="status-dot green"></span>Working</td>
          <td>Validates <code>dishId</code>, prevents duplicates, correct error messages</td>
        </tr>
        <tr>
          <td>Backend</td>
          <td>Review routes &amp; validation</td>
          <td><span class="status-dot green"></span>Working</td>
          <td>All validators in place; <code>dishId</code> required</td>
        </tr>
        <tr>
          <td>Backend</td>
          <td>Webhook handler</td>
          <td><span class="status-dot yellow"></span>Warning</td>
          <td>Sets <code>status: PENDING</code> on payment â€” correct, but needs monitoring</td>
        </tr>
        <tr>
          <td>Frontend</td>
          <td><code>OrdersPage</code> â€” Write Review button</td>
          <td><span class="status-dot red"></span>Broken (cascades from backend)</td>
          <td><code>canReviewOrder()</code> always returns false; button never renders</td>
        </tr>
        <tr>
          <td>Frontend</td>
          <td><code>ReviewFormPage</code> â€” order selection</td>
          <td><span class="status-dot red"></span>Broken (cascades from backend)</td>
          <td>Empty state always shown because eligible-orders list is empty</td>
        </tr>
        <tr>
          <td>Frontend</td>
          <td><code>ReviewFormPage</code> â€” dish selection</td>
          <td><span class="status-dot green"></span>Working (once data arrives)</td>
          <td>Correctly filters already-reviewed dishes from the dropdown</td>
        </tr>
        <tr>
          <td>Frontend</td>
          <td><code>MyReviewsPage</code></td>
          <td><span class="status-dot green"></span>Working</td>
          <td>Edit / delete / copy-coupon flows are intact</td>
        </tr>
        <tr>
          <td>Frontend</td>
          <td><code>ChefReviewsPage</code></td>
          <td><span class="status-dot green"></span>Working</td>
          <td>Approve / reject / delete flows are intact</td>
        </tr>
        <tr>
          <td>Schema</td>
          <td><code>@@unique([orderId, dishId])</code></td>
          <td><span class="status-dot green"></span>Working</td>
          <td>Duplicate-dish-review prevention enforced at DB level</td>
        </tr>
        <tr>
          <td>Schema</td>
          <td>Review â†’ Dish FK</td>
          <td><span class="status-dot green"></span>Working</td>
          <td>Foreign key and index correctly applied</td>
        </tr>
      </tbody>
    </table>
  </div>

  <hr class="divider">

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 4: IMPROVEMENTS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="section">
    <div class="section-header">
      <span class="section-num">04</span>
      <h2>Recommended Improvements</h2>
    </div>
    <p>Beyond the critical bug fix, the following improvements would meaningfully raise the reliability, user experience, and maintainability of the review system. They are ordered by priority.</p>

    <div class="improvements">

      <!-- 1 -->
      <div class="improvement-card">
        <div class="improvement-card-header">
          <h3>1. Centralize Order Status Transitions</h3>
          <span class="priority-badge high">High Priority</span>
        </div>
        <p>Order status is updated in at least three separate places (<code>order.controller.ts</code>, <code>order.routes.ts</code>, <code>webhook.routes.ts</code>). This spread is why <code>completedAt</code> was missed. A single <code>updateOrderStatus(orderId, newStatus)</code> service function should own all side-effects â€” setting <code>completedAt</code>, logging transitions, firing notifications â€” so no path can forget them.</p>
        <div class="code-block">
          <div class="code-block-header">
            <span class="filename">backend/src/services/order.service.ts</span>
            <span class="lang">TypeScript â€” proposed</span>
          </div>
          <pre><span class="token-keyword">export async function</span> <span class="token-function">setOrderStatus</span>(
  orderId: <span class="token-keyword">string</span>,
  status: OrderStatus
) {
  <span class="token-keyword">return</span> prisma.order.<span class="token-function">update</span>({
    where: { id: orderId },
    data: {
      status,
      <span class="token-comment">// completedAt stamped here, in one place, forever</span>
      ...(status === <span class="token-string">'COMPLETED'</span> &amp;&amp; { completedAt: <span class="token-keyword">new</span> <span class="token-function">Date</span>() }),
    },
  });
}</pre>
        </div>
      </div>

      <!-- 2 -->
      <div class="improvement-card">
        <div class="improvement-card-header">
          <h3>2. Remove the 30-Day Review Window (or Make It Configurable)</h3>
          <span class="priority-badge high">High Priority</span>
        </div>
        <p>The current 30-day window is a good-faith UX constraint, but it creates a silent cliff â€” customers who try to review on day 31 see "No orders available" with no explanation. Two improvements are needed together: make the window an environment variable so the chef can tune it, and surface a clear message to the customer when an order is eligible but expired.</p>
        <div class="code-block">
          <div class="code-block-header">
            <span class="filename">backend/src/controllers/review.controller.ts</span>
            <span class="lang">TypeScript â€” improved</span>
          </div>
          <pre><span class="token-keyword">const</span> REVIEW_WINDOW_DAYS = parseInt(
  process.env.REVIEW_WINDOW_DAYS ?? <span class="token-string">'30'</span>, <span class="token-number">10</span>
);

<span class="token-keyword">const</span> cutoff = <span class="token-keyword">new</span> <span class="token-function">Date</span>();
cutoff.<span class="token-function">setDate</span>(cutoff.<span class="token-function">getDate</span>() - REVIEW_WINDOW_DAYS);</pre>
        </div>
      </div>

      <!-- 3 -->
      <div class="improvement-card">
        <div class="improvement-card-header">
          <h3>3. Show Review Status on the Orders Page Inline</h3>
          <span class="priority-badge high">High Priority</span>
        </div>
        <p>The current UX requires customers to know to look for the "Write Review" button. A better pattern is to show a per-dish review status badge directly on the order card â€” "â­ Reviewed", "âœï¸ Write a Review", "â³ Pending Approval", "âœ… Coupon Earned" â€” so the entire review lifecycle is visible without navigating away. This eliminates confusion when the button doesn't appear.</p>
      </div>

      <!-- 4 -->
      <div class="improvement-card">
        <div class="improvement-card-header">
          <h3>4. Add Loading &amp; Error States to the Eligible Orders Query</h3>
          <span class="priority-badge medium">Medium Priority</span>
        </div>
        <p>Both <code>OrdersPage</code> and <code>ReviewFormPage</code> query <code>/reviews/eligible-orders</code>, but neither renders a meaningful error state if that request fails (network error, 401 timeout, etc.). A customer hitting a transient backend error would see "No orders available" â€” indistinguishable from a truly empty list. The fix is simple: expose the <code>isError</code> flag from React Query and render a retry prompt.</p>
        <div class="code-block">
          <div class="code-block-header">
            <span class="filename">frontend/src/pages/OrdersPage.tsx</span>
            <span class="lang">TypeScript â€” improved</span>
          </div>
          <pre><span class="token-keyword">const</span> { data, isLoading, <span class="token-highlight">isError</span>, <span class="token-highlight">refetch</span> } = useQuery({ ... });

<span class="token-keyword">if</span> (<span class="token-highlight">isError</span>) <span class="token-keyword">return</span> (
  &lt;ErrorBanner message=<span class="token-string">"Could not load review eligibility"</span>
               onRetry={<span class="token-highlight">refetch</span>} /&gt;
);</pre>
        </div>
      </div>

      <!-- 5 -->
      <div class="improvement-card">
        <div class="improvement-card-header">
          <h3>5. Notify the Customer When Their Review Is Approved</h3>
          <span class="priority-badge medium">Medium Priority</span>
        </div>
        <p>The chef approval step that generates a coupon is a key monetization moment, but customers currently have no push signal â€” they must manually check "My Reviews" to discover they've earned a discount. An email notification at the point of approval (the existing email infra is already wired up) would close this loop and drive repeat orders. The <code>approveReview</code> controller already creates the coupon; it just needs one more call to the email service.</p>
      </div>

      <!-- 6 -->
      <div class="improvement-card">
        <div class="improvement-card-header">
          <h3>6. Add Integration Tests for the Review Flow</h3>
          <span class="priority-badge medium">Medium Priority</span>
        </div>
        <p>The existing headless tests run against simulated in-memory data and correctly verified the per-dish logic â€” but they did not catch the <code>completedAt</code> bug because they never hit a real database or the chef's status-update endpoint. A Vitest or Supertest integration test suite that exercises the full path (create order â†’ update status to COMPLETED â†’ verify eligible-orders response) would have caught this before deployment.</p>
      </div>

      <!-- 7 -->
      <div class="improvement-card">
        <div class="improvement-card-header">
          <h3>7. Guard Against Review Submission on Disappeared Dishes</h3>
          <span class="priority-badge low">Low Priority</span>
        </div>
        <p>The Prisma schema uses <code>onDelete: Restrict</code> on the <code>Dish â†’ OrderItem</code> relation, which prevents a dish from being deleted if it has been ordered. However, a dish can be set to <code>UNAVAILABLE</code>. If a dish is later permanently deleted by an admin (bypassing the restriction), the <code>Review.dishId</code> foreign key would cause cascading errors. Consider adding soft-delete semantics to dishes and confirming the <code>Restrict</code> constraint is honoured in all admin flows.</p>
      </div>

    </div>
  </div>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 5: QUICK REFERENCE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <div class="section">
    <div class="section-header">
      <span class="section-num">05</span>
      <h2>Fix Checklist</h2>
    </div>

    <div class="callout info">
      <div class="callout-title">ğŸ“‹ Deploy in This Order</div>
      <ul>
        <li><strong>Step 1:</strong> Add <code>...(status === 'COMPLETED' &amp;&amp; { completedAt: new Date() })</code> to every order-status-update call in the backend.</li>
        <li><strong>Step 2:</strong> Deploy to Render (or your environment). Prisma schema requires no migration â€” <code>completedAt</code> already exists as a nullable column.</li>
        <li><strong>Step 3:</strong> Run the one-time SQL back-fill to stamp <code>completedAt = updatedAt</code> for any orders already in <code>COMPLETED</code> state.</li>
        <li><strong>Step 4:</strong> Verify by marking a test order as COMPLETED and confirming it appears in <code>GET /reviews/eligible-orders</code>.</li>
        <li><strong>Step 5:</strong> Confirm the "Write Review" button appears on <code>/orders</code> and the review form renders dishes correctly.</li>
      </ul>
    </div>
  </div>

</div>

<div class="footer">
  TrapHouse Kitchen v2 Â· Review System Evaluation Â· February 12, 2026
</div>

</body>
</html>
